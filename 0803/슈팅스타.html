<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>슈팅 스타타</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: white; color: black; }
    #startBtn { position: absolute; top: 20px; left: 20px; padding: 10px; font-size: 16px; }
  </style>
</head>
<body>
  <button id="startBtn">게임 시작</button>
  <script>
let bullets = [];
let enemies = [];
let player;
let gameStarted = true;
let paused = false;
let score = 0;
let waveCleared = false;
let bossEntrance = false;
let bossFlashAlpha = 0;
let bossEntranceTimer = 0;
let wave = 1;
let killCount = 0;

let playerSheet;
let playerFrames = [];
let frameIndex = 0;
let frameSpeed = 6;

function preload() {
  playerSheet = loadImage('https://opengameart.org/sites/default/files/character_32x32.png');
}

function setup() {
  createCanvas(windowWidth, windowHeight);
  for (let i = 0; i < 4; i++) {
    playerFrames.push(playerSheet.get(i * 32, 0, 32, 32));
  }
  player = new Player();
  spawnEnemies(wave);
}

function draw() {
  if (!gameStarted || paused) return;
  background(255);

  if (bossEntrance && bossEntranceTimer < 120) {
    fill(255, 0, 0, bossFlashAlpha);
    rect(0, 0, width, height);
    bossFlashAlpha -= 5;
    fill(0);
    textSize(48);
    textAlign(CENTER);
    text("!!! BOSS 등장 !!!", width / 2, height / 2);
    bossEntranceTimer++;
    return;
  }

  player.update();
  player.display();

  for (let i = enemies.length - 1; i >= 0; i--) {
    let enemy = enemies[i];
    enemy.display();
  }

  for (let i = enemies.length - 1; i >= 0; i--) {
    for (let j = bullets.length - 1; j >= 0; j--) {
      if (bullets[j].hits(enemies[i])) {
        if (enemies[i].isBoss) {
          enemies[i].health -= 10;
          enemies[i].flashTimer = 5;
          bullets.splice(j, 1);
          if (enemies[i].health <= 0) {
            score += 10;
            enemies.splice(i, 1);
            killCount++;
          }
        } else {
          score += enemies[i].bonus ? 5 : 1;
          bullets.splice(j, 1);
          enemies.splice(i, 1);
          killCount++;
        }
        break;
      }
    }
  }

  if (killCount >= 10) {
    wave++;
    killCount = 0;
    spawnEnemies(wave);
  }
}

function spawnEnemies(n) {
  enemies = [];
  bossEntrance = false;
  bossEntranceTimer = 0;

  let isBossWave = [5, 10, 15].includes(n);
  if (isBossWave) {
    enemies.push(new Enemy(true, n));
    bossEntrance = true;
    bossFlashAlpha = 255;
  }
  for (let i = 0; i < n * 2; i++) {
    enemies.push(new Enemy(false));
  }
  waveCleared = false;
}

class Enemy {
  constructor(isBoss = false, waveNum = 0) {
    this.isBoss = isBoss;
    this.r = isBoss ? 60 : 20;
    this.x = random(width);
    this.y = random(height);
    this.flashTimer = 0;

    if (isBoss) {
      this.bossWave = waveNum;
      if (waveNum === 5) {
        this.health = 30;
        this.name = '보스 파이써른';
        this.speed = 1;
      } else if (waveNum === 10) {
        this.health = 50;
        this.name = '보스 자바';
        this.speed = 1.5;
      } else if (waveNum === 15) {
        this.health = 100;
        this.name = '보스 GPT';
        this.speed = 2;
      }
    } else {
      this.health = 1;
      this.speed = 2;
      this.bonus = random() < 0.1;
    }
  }

  display() {
    if (this.isBoss && this.flashTimer > 0) {
      fill(255, 255, 0);
      this.flashTimer--;
    } else {
      fill(this.isBoss ? 'purple' : 'yellow');
    }
    ellipse(this.x, this.y, this.r * 2);

    if (this.isBoss) {
      fill(0);
      textAlign(CENTER);
      text(this.name, this.x, this.y - this.r - 10);
      fill(255, 0, 0);
      rect(this.x - 30, this.y - this.r - 20, 60, 5);
      fill(0, 255, 0);
      let maxHp = (this.bossWave === 15 ? 100 : this.bossWave === 10 ? 50 : 30);
      let ratio = this.health / maxHp;
      rect(this.x - 30, this.y - this.r - 20, 60 * ratio, 5);
    }
  }
}

class Bullet {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.r = 5;
  }

  hits(enemy) {
    return dist(this.x, this.y, enemy.x, enemy.y) < this.r + enemy.r;
  }
}

class Player {
  constructor() {
    this.x = width / 2;
    this.y = height / 2;
    this.speed = 4;
  }

  update() {
    let moving = false;
    if (keyIsDown(87)) { this.y -= this.speed; moving = true; }
    if (keyIsDown(83)) { this.y += this.speed; moving = true; }
    if (keyIsDown(65)) { this.x -= this.speed; moving = true; }
    if (keyIsDown(68)) { this.x += this.speed; moving = true; }
    if (moving && frameCount % frameSpeed === 0) {
      frameIndex = (frameIndex + 1) % playerFrames.length;
    }
  }

  display() {
    image(playerFrames[frameIndex], this.x - 16, this.y - 16);
  }
}
  </script>
</body>
</html>
